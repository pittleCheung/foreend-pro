/**
 * ioc是什么  di是如何诞生的 他们解决了什么问题

IoC(Inversion of Control)即控制反转。在开发中， IoC 意味着你设计好的对象交给容器控制，而不是使用传统的方式，在对象内部直接控制
谁控制谁，控制什么，为何是反转，哪些方面反转了
谁控制谁，控制什么：在传统的程序设计中，我们直接在对象内部通过 new 的方式创建对象，是程序主动创建依赖对象； 而 IoC 是有专门一个容器来创建这些对象，即由 IoC 容器控制对象的创建,谁控制谁？当然是 IoC 容器控制了对象；控制什么？主要是控制外部资源(依赖对象)获取
为何是反转了，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在程序中主动控制去获取依赖对象，也就是正转； 而反转则是由容器来帮忙创建及注入依赖对象,为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转了；哪些方面反转了？依赖对象的获取被反转了
IoC是一种思想，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度
传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试； 有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器注入组合对象，所以对象之间是松散耦合。 这样也便于测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活
其实 IoC 对编程带来的最大改变不是从代码上，而是思想上，发生了主从换位的变化。应用程序本来是老大，要获取什么资源都是主动出击，但在 IoC 思想中，应用程序就变成被动了，被动的等待 IoC 容器来创建并注入它所需的资源了

DI(Dependency Injection) #依赖注入
对于控制反转来说，其中最常见的方式叫做 依赖注入，简称为 DI（Dependency Injection）
组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中
通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现
理解 DI 的关键是 谁依赖了谁，为什么需要依赖，谁注入了谁，注入了什么　
谁依赖了谁：当然是应用程序依赖 IoC 容器
为什么需要依赖：应用程序需要 IoC 容器来提供对象需要的外部资源（包括对象、资源、常量数据）
谁注入谁：很明显是 IoC 容器注入应用程序依赖的对象；
注入了什么：注入某个对象所需的外部资源（包括对象、资源、常量数据）
IoC 和 DI 是同一个概念的不同角度描述,依赖注入明确描述了被注入对象依赖 IoC 容器配置依赖对象
*/

export interface Monitor {}
class Monitor27inch implements Monitor {}

interface Host {}
class LegendHost implements Host {}

class Computer {
  monitor: Monitor
  host: Host
  constructor() {
    this.monitor = new Monitor27inch()
    this.host = new LegendHost()
  }
  startup() {
    console.log("组装好了,可以开机了")
  }
}
let computer = new Computer()
computer.startup()
